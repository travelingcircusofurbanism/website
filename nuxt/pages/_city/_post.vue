<template>
  <PostFullDisplay
    :key="(title.en || title.ja) + $i18n.locale"
    :title="title"
    :content="content[displayLanguage]"
    :category="category"
    :mapPosition="mapPosition"
    :city="city"
    :date="date"
    :slug="slug"
    :description="description"
    :publicPath="publicPath"
    :image="image"
    :polygons="polygons"
    :public="public"
    :preview="preview"
    :tags="tags"
    :languages="languages"
    :displayLanguage="displayLanguage"
  />
</template>

<script>
import axios from 'axios'
import PostFullDisplay from '~/components/PostFullDisplay'
const {
  capitalize,
} = require('~/assets/commonFunctions.js')

export default {
  scrollToTop: true,
  layout: 'default',
  head() {
    const title = this.capitalize(
      this.title[this.displayLanguage] ||
        this.title.en ||
        this.title.ja,
    )
    const image = this.image // does it have an image?
      ? this.image.substring(0, 4) === 'http' // is it external?
        ? this.image // if so, use it
        : `https://www.travelingcircusofurbanism.com${encodeURI(
            this.image,
          )}` // otherwise, give it a prefix
      : 'https://www.travelingcircusofurbanism.com/assets/sitethumbnail.jpg' // fallback to the site thumbnail.
    const description =
      this.description[this.displayLanguage] ||
      this.description.en ||
      this.description.ja
    const url = `https://www.travelingcircusofurbanism.com${this.localePath(
      {
        name: 'city-post',
        params: { city: this.city, post: this.slug },
      },
    )}`
    let dateYMDKebab = this.date
      .replace(/\s/g, '')
      .split('/')
    dateYMDKebab = [
      dateYMDKebab[2],
      dateYMDKebab[0],
      dateYMDKebab[1],
    ].join('-')

    const meta = [
      {
        property: 'og:title',
        content: title,
      },
      {
        hid: `og:type`,
        property: 'og:type',
        content: 'article',
      },
      {
        hid: `og:description`,
        property: 'og:description',
        content: description,
      },
      {
        property: 'description',
        content: description,
        hid: `description`,
      },
      {
        property: 'og:url',
        content: url,
      },
      {
        hid: `og:image`,
        property: 'og:image',
        content: image,
      },
    ]

    if (this.displayLanguage !== this.$i18n.locale)
      meta.push({
        rel: 'canonical',
        href: `https://www.travelingcircusofurbanism.com${this.switchLocalePath(
          this.displayLanguage,
        )}`,
      })

    if (!this.public[this.displayLanguage] && this.preview)
      meta.push({
        name: 'robots',
        content: 'noindex',
      })

    const structuredJSON = {
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: title,
      image: image,
      author: 'Mariko Sugita',
      genre: 'urbanism',
      keywords:
        this.displayLanguage === 'ja'
          ? '都市, 建築, アーバニズム, まちづくり, 都市デザイン'
          : 'Urbanism, Architecture, Urban Studies, Urban Design, Travel',
      wordcount: `${
        (this.content[this.displayLanguage] || '').split(
          ' ',
        ).length
      }`,
      publisher: {
        '@type': 'Organization',
        name: 'Traveling Circus of Urbanism',
        logo: {
          '@type': 'ImageObject',
          url:
            'https://www.travelingcircusofurbanism.com/assets/logovertblue.png',
        },
      },
      url: url,
      mainEntityOfPage: {
        '@type': 'WebPage',
        '@id': 'https://www.travelingcircusofurbanism.com/',
      },
      datePublished: dateYMDKebab,
      dateCreated: dateYMDKebab,
      dateModified: dateYMDKebab,
      description: description,
      articleBody: `${(
        this.content[this.displayLanguage] || ''
      )
        .replace(/<[^>]*>/gi, '')
        .replace(/(\n|\r)+/g, ' ')
        .replace(/(\\n)+/gi, ' ')}`,
    }

    return {
      title: this.capitalize(
        this.title[this.displayLanguage] ||
          this.title.en ||
          this.title.ja,
      ),
      meta,
      __dangerouslyDisableSanitizers: ['script'],
      script: [
        {
          innerHTML: JSON.stringify(structuredJSON),
          type: 'application/ld+json',
        },
      ],
    }
  },

  components: {
    PostFullDisplay,
  },

  async asyncData({ route, redirect, error, env, store }) {
    if (route.path.indexOf('_nuxt/') > -1)
      return error({
        statusCode: 404,
        message: 'Page not found.',
      })

    const removeCityAndTrailingSlash = (string) =>
      string.replace(/\/$/, '')
    const slug = decodeURI(route.path)
      .replace('/ja/', '/')
      .replace(/\/$/, '')
      .replace(/^\/?[^\/]*\//g, '')
    const city = decodeURI(route.path)
      .replace('/ja/', '/')
      .replace(/^\//g, '')
      .replace(/\/.*$/g, '')
      .toLowerCase()

    const path = `/posts/${city}/${slug}/`
    const publicPath = `/${city}/${slug}/`

    const autoGeneratedData = store.state.allPosts.find(
      (p) => {
        return (
          city.toLowerCase() === p.city.toLowerCase() &&
          slug.toLowerCase() === p.slug.toLowerCase()
        )
      },
    )

    if (!autoGeneratedData) {
      console.log(
        'Error: Unable to find generated data for ' + path,
      )
      return error({
        statusCode: 404,
        message: 'Page not found.',
      })
    }

    const content = {}
    if (process.server && !process.client) {
      // can just get data with fs on server
      let fs
      if (process.server) fs = require('fs')
      try {
        content.en = fs.readFileSync(
          './nuxt/static' + path + 'en.html',
          'utf8',
        )
      } catch (e) {}
      try {
        content.ja = fs.readFileSync(
          './nuxt/static' + path + 'ja.html',
          'utf8',
        )
      } catch (e) {}
    } else {
      // have to use axios on the browser. yes, asyncData runs between pages on the browser. idk why.
      const axiosConfig = {
        validateStatus: (status) => true,
      }
      const contentPromises = []
      try {
        if (autoGeneratedData.languages.en)
          contentPromises.push(
            axios
              .get(path + 'en.html', axiosConfig)
              .then(
                (response) => (content.en = response.data),
              )
              .catch((e) => console.log(e)),
          )
        if (autoGeneratedData.languages.ja)
          contentPromises.push(
            axios
              .get(path + 'ja.html', axiosConfig)
              .then(
                (response) => (content.ja = response.data),
              )
              .catch((e) => console.log(e)),
          )
        await Promise.all(contentPromises)
      } catch (e) {
        console.log(e)
        return error({
          statusCode: 404,
          message: 'Page not found.',
        })
      }
    }
    if (!(content.en || content.ja))
      return error({
        statusCode: 404,
        message: 'Page not found.',
      })

    return {
      path,
      publicPath,
      slug,
      city,
      content,
      preview: autoGeneratedData.preview,
      tags: [],
      ...autoGeneratedData,
      mapPosition: autoGeneratedData.mapPosition
        ? Array.isArray(autoGeneratedData.mapPosition)
          ? autoGeneratedData.mapPosition
          : [autoGeneratedData.mapPosition]
        : [],
      polygons: autoGeneratedData.polygons
        ? autoGeneratedData.polygons
        : null,
    }
  },

  computed: {
    isDev() {
      return this.$store.state.viewingAsDev
    },

    displayLanguage() {
      if (
        this.content[this.$i18n.locale] &&
        (this.public[this.$i18n.locale] || this.isDev)
      )
        return this.$i18n.locale
      else if (
        this.content.en &&
        (this.public.en === true || this.isDev)
      )
        return 'en'
      else if (
        this.content.ja &&
        (this.public.ja === true || this.isDev)
      )
        return 'ja'
      else if (
        this.content[this.$i18n.locale] &&
        this.preview === true
      )
        return this.$i18n.locale
      return null
    },
  },

  created() {
    this.$store.commit('setBreadcrumbs', [
      {
        label: this.city,
        url: this.localePath({
          name: 'city',
          params: { city: this.city },
        }),
      },
      {
        label:
          this.title[this.$i18n.locale] ||
          this.title.en ||
          this.title.ja,
        url: this.localePath({
          name: 'city-post',
          params: { city: this.city, post: this.slug },
        }),
      },
    ])
  },

  methods: {
    capitalize,
  },
}
</script>

<style lang="scss" scoped></style>
